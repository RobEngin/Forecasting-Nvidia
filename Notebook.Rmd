---
title: "R Notebook"
output: html_notebook
---
### Markdown instruction

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.



### Import Library

```{r}
#install.packages("dplyr")
library(ggplot2)
library(dplyr)
library(corrplot)
library(readxl)
library(lmtest) 
library(forecast)
library(DIMORA)
library(fpp2)
```


### Data upload

```{r}
btc_price <- read.csv("BTC_price_Bitcoin.csv", sep=",", header = TRUE) # daily
dollar_circulation <- read.csv("CURRCIR.csv", sep=",", header = TRUE) # monthly
btc_addr_total <- read.csv("BTC_Total Addresses_Bitcoin.csv", sep=",", header = TRUE) # daily
btc_hashrate_difficulty <- read.csv("BTC_Hash Rate_Difficulty.csv", sep=",", header = TRUE) # daily
btc_transaction <- read.csv("BTC_Number of Transactions_Bitcoin.csv", sep=",", header = TRUE) # daily
btc_miner_rewards <- read.csv("BTC_Miner Rewards_undefined.csv", sep=",", header = TRUE) # daily

btc_avg_fees <- read.csv("BTC_Average Transaction Fees_Bitcoin.csv", sep=",", header = TRUE) # daily not null from 29/11/09
btc_days_halving <- read.csv("days_to_halving.csv", sep=",", header = TRUE) # daily
```

Function
```{r}
# Normalize data
norm <- function(lista_numeri) {
  # Calcola il minimo e il massimo della lista
  minimo <- min(lista_numeri)
  massimo <- max(lista_numeri)
  
  # Normalizza la lista tra 0 e 1
  lista_normalizzata <- (lista_numeri - minimo) / (massimo - minimo)
  
  # Restituisci la lista normalizzata
  return(lista_normalizzata)
}
# From daily to monthly
monthly <- function(data, col_date) {
  # Assicurati che la colonna 'DateTime' sia di tipo Date
  data[[col_date]] <- as.Date(data[[col_date]], format = "%Y-%m-%dT%H:%M:%S.000Z")
  
  # Estrai il mese dalla colonna 'DateTime'
  data <- data %>%
    mutate(Month = format(get(col_date), "%Y-%m"))
  
  # Seleziona solo colonne numeriche per calcolare la media
  cols_num <- names(data)[sapply(data, is.numeric)]
  
  # Calcola la media delle colonne numeriche per ogni mese
  new_dataset <- data %>%
    group_by(Month) %>%
    summarise(across(all_of(cols_num), mean))
  
  new_dataset$Month <- as.Date(paste(new_dataset$Month, "01", sep = "-"))
  
  # Restituisci il nuovo dataset
  return(new_dataset)
}
```



### EDA

From day to month
```{r}
btc_price <- monthly(btc_price, "DateTime")
btc_addr_total <- monthly(btc_addr_total, "DateTime")
btc_hashrate_difficulty <- monthly(btc_hashrate_difficulty, "DateTime")
btc_transaction <- monthly(btc_transaction, "DateTime")
btc_miner_rewards <- monthly(btc_miner_rewards, "DateTime")
btc_avg_fees <- monthly(btc_avg_fees, "DateTime")
#btc_days_halving <- monthly(btc_days_halving, "date")
```

Global date
```{r}
start_date <- as.Date("2011-09-01") # 2011-09-01
end_date <- as.Date("2023-10-01") # 2023-10-01
```

Date
```{r}
btc_price <- btc_price[btc_price$Month >= start_date & btc_price$Month <= end_date, ] # price
dollar_circulation <- dollar_circulation[dollar_circulation$DATE >= start_date & dollar_circulation$DATE <= end_date, ] # price
btc_addr_total <- btc_addr_total[btc_addr_total$Month >= start_date & btc_addr_total$Month <= end_date, ] # price
btc_hashrate_difficulty <- btc_hashrate_difficulty[btc_hashrate_difficulty$Month >= start_date & btc_hashrate_difficulty$Month <= end_date, ] # price
btc_transaction <- btc_transaction[btc_transaction$Month >= start_date & btc_transaction$Month <= end_date, ] # price

btc_miner_rewards <- btc_miner_rewards[btc_miner_rewards$Month >= start_date & btc_miner_rewards$Month <= end_date, ] # price
```

Error in btc_miner_rewards
```{r}
nrows <- nrow(btc_miner_rewards)
row_pre <- btc_miner_rewards[(nrows - 29):(nrows - 15), -1]
btc_miner_rewards[(nrows - 14):nrows, -1] <- row_pre
```

Log Data
```{r}
btc_price$log_Price <- log(btc_price$Price)
dollar_circulation$log_CURRCIR <- log(dollar_circulation$CURRCIR)
btc_addr_total$log_total <- log(btc_addr_total$Total.With.Balance)
btc_hashrate_difficulty$log_HashRate <- log(btc_hashrate_difficulty$Hash.Rate)
btc_transaction$log_transaction <- log(btc_transaction$Number.Of.Transactions)
btc_miner_rewards$log_Rewards <- log(btc_miner_rewards$Rewards)
```

Plot
```{r}
ggplot(btc_price, aes(x = Month, y = log_Price)) +
  geom_line(color = "orange", size = 1) +
  labs(x = "Date", y = "Price Bitcoin", title = "Bitcoin price over time")
```

Plot
```{r}
ggplot() +
  geom_line(data = btc_price, aes(x = Month, y = norm(log_Price)), color = "orange", size = 1, linetype = "solid") +
  geom_line(data = dollar_circulation, aes(x = as.Date(DATE), y = norm(log_CURRCIR)), color = "red", size = 0.2, linetype = "solid") +
  geom_line(data = btc_addr_total, aes(x = Month, y = norm(log_total)), color = "green", size = 0.2, linetype = "solid") +
  geom_line(data = btc_transaction, aes(x = Month, y = norm(log_transaction)), color = "black", size = 0.2, linetype = "solid") +
  geom_line(data = btc_hashrate_difficulty, aes(x = Month, y = norm(log_HashRate)), color = "blue", size = 0.2, linetype = "solid") +
  geom_line(data = btc_miner_rewards, aes(x = Month, y = norm(log_Rewards)), color = "blue", size = 0.2, linetype = "solid") +

  labs(x = "Date", y = "Log(Price)", title = "Bitcoin Price and other Time Series") +
  scale_linetype_manual(name = "Legend", values = c("solid", "dashed"), labels = c("Bitcoin Price", "Another Time Series"))
```

Create Dataset
```{r}
dataset_log <- data.frame(price = btc_price$log_Price, 
                      dollar_circulation = dollar_circulation$log_CURRCIR,
                      total_addr = btc_addr_total$log_total,
                      transaction = btc_transaction$log_transaction,
                      hashrate = btc_hashrate_difficulty$log_HashRate,
                      rewards = btc_miner_rewards$log_Rewards)

dataset <- data.frame(price = btc_price$Price, 
                      dollar_circulation = dollar_circulation$CURRCIR,
                      total_addr = btc_addr_total$Total.With.Balance,
                      transaction = btc_transaction$Number.Of.Transactions,
                      hashrate = btc_hashrate_difficulty$Hash.Rate,
                      rewards = btc_miner_rewards$Rewards)
```


```{r}
acf(dataset$price)
mat <- cor(dataset)

corrplot(mat, method = "color", addCoef.col = "black")
```

Differentation
```{r}
dataset$price_diff <- c(NA, diff(dataset$price))
dataset$dollar_circulation_diff <- c(NA, diff(dataset$dollar_circulation))
dataset$total_addr_diff <- c(NA, diff(dataset$total_addr))
dataset$transaction_diff <- c(NA, diff(dataset$transaction))
dataset$hashrate_diff <- c(NA, diff(dataset$hashrate))
dataset$rewards_diff <- c(NA, diff(dataset$rewards))
```

```{r}
# Rimuovi le variabili temporali originali
dataset_senza_tempo <- subset(dataset, select = -c(price, dollar_circulation, total_addr, transaction, hashrate, rewards))
# Calcola la matrice di correlazione
matrix_correlazione <- cor(dataset_senza_tempo, use = "complete.obs")
# Visualizza la matrice di correlazione
print(matrix_correlazione)
corrplot(matrix_correlazione, method = "color", addCoef.col = "black")

```



### Linear Regression

```{r}
price <- log(dataset$price)
tt <- 1:NROW(dataset)

plot(tt, price, xlab="Time", ylab="Bitcoin price")
```
autocorrelation function
```{r}
acf(price)
```

fit a linear regression model 
```{r}
fit1 <- lm(price~ tt)
summary(fit1)
```

```{r}
plot(tt, price, xlab="Time", ylab="Bitcoin price")
abline(fit1, col=3)
```

check the residuals? are they autocorrelated? Test of DW
```{r}
dwtest(fit1)
```

check the residuals
```{r}
resfit1<- residuals(fit1)
plot(resfit1,xlab="Time", ylab="residuals" )
```

let us do the same with a linear model for time series, so we transform the data into a 'ts' object
```{r}
price.ts <- ts(price, frequency = 4)
ts.plot(price.ts, type="o")

## we fit a linear model with the tslm function
fitts<- tslm(price.ts~trend)

###obviously it gives the same results of the first model
summary(fitts)

dwtest(fitts)
```



### Linear regression with trend and seasonality and forecasting exercise 

```{r}
#take a portion of data and fit a linear model with tslm
price1 <- window(price.ts, start=1, end=31 -.1)
plot(price1)
```

```{r}
m1<- tslm(price1 ~ trend+season)
summary(m1)
fit<- fitted(m1)

plot(price1)
lines(fitted(m1), col=2)

fore <- forecast(m1)
plot(fore)
```

```{r}
#analysis of residuals
res<- residuals(m1) 
plot(res) 
#the form of residuals seems to indicate the presence of negative autocorrelation
Acf(res)

dw<- dwtest(m1, alt="two.sided")
dw
```


### Nonlinear models for new product growth (diffusion models)

```{r}
bm_tw<-BM(price,display = T)
summary(bm_tw)


pred_bmtw<- predict(bm_tw, newx=c(1:146))
pred.insttw<- make.instantaneous(pred_bmtw)


plot(price, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, cex=0.6, xlim=c(1,146))
lines(pred.insttw, lwd=2, col=2)


###GBMr1
GBMr1tw<- GBM(price,shock = "rett",nshock = 1,prelimestimates = c(4.463368e+04, 1.923560e-03, 9.142022e-02, 24,38,-0.1))


######GBMe1

GBMe1tw<- GBM(price,shock = "exp",nshock = 1,prelimestimates = c(4.463368e+04, 1.923560e-03, 9.142022e-02, 12,0.1,0.1))
summary(GBMe1tw)

pred_GBMe1tw<- predict(GBMe1tw, newx=c(1:146))
pred_GBMe1tw.inst<- make.instantaneous(pred_GBMe1tw)

plot(price, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, cex=0.6, xlim=c(1,146))
lines(pred_GBMe1tw.inst, lwd=2, col=2)

```
```{r}
######GGM 
GGM_tw<- GGM(price, prelimestimates=c(4.463368e+04, 0.001, 0.01, 1.923560e-03, 9.142022e-02))
summary(GGM_tw)

pred_GGM_tw<- predict(GGM_tw, newx=c(1:146))
pred_GGM_tw.inst<- make.instantaneous(pred_GGM_tw)

plot(price, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, cex=0.6, xlim=c(1,146))
lines(pred_GGM_tw.inst, lwd=2, col=2)
lines(pred.insttw, lwd=2, col=3)

###Analysis of residuals
res_GGMtw<- residuals(GGM_tw)
acf<- acf(residuals(GGM_tw))


fit_GGMtw<- fitted(GGM_tw)
fit_GGMtw_inst<- make.instantaneous(fit_GGMtw)
```
```{r}
####SARMAX refining
library(forecast)
####SARMAX model with external covariate 'fit_GGM' 
s2 <- Arima(cumsum(price), order = c(3,0,1), seasonal=list(order=c(3,0,1), period=4),xreg = fit_GGMtw)
summary(s2)
pres2 <- make.instantaneous(fitted(s2))


plot(price, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(fit_GGMtw_inst, lwd=1, lty=2)
lines(pres2, lty=1,lwd=1)
```

### ARIMA models

```{r}
library(fpp2)
library(forecast) 
?fpp2

plot(price)
Acf(price)
Pacf(price)
pricets<- tsdisplay(price)
```

```{r}
###General indication: if the ACF is exponentially decaying or sinusoidal and there is a significant spike at lag p in PACF and nothing else, 
##it may be an ARMA(p,d,0). If the PACF is exponentially decaying or sinusoidal and there is a significant spike at lag p in ACF and nothing else, it may be an ARMA(0,d,q). 

arima1<- Arima(price, order=c(0,0,3))
summary(arima1)

resid1<- residuals(arima1)
tsdisplay(resid1)


plot(price)
lines(fitted(arima1), col=2)

for1<- forecast(arima1)
plot(for1)
```


First Arima model
```{r}
plot(price, ylab="retail index",xlab="year")
tsdisplay(price)

##first difference
diff1<- diff(price) 
###seasonal difference
diff4<- diff(price, lag=4) 
tsdisplay(diff1)
tsdisplay(diff4)


####first Arima model 
a1<- Arima(price, order=c(0,1,1), seasonal=c(0,0,1))
fit1<- fitted(a1)

plot(price)
lines(fit1, col=2)

f1<- forecast(a1)
plot(f1)

r1<- residuals(a1)
tsdisplay(r1) 
```

Second Arima model
```{r}
a2<- Arima(price, order=c(0,1,1), seasonal=c(0,0,2))
fit2<- fitted(a2)

plot(price)
lines(fit2, col=2)

f2<- forecast(a2)
plot(f2)

r2<- residuals(a2)
tsdisplay(r2) 
```

Third Arima model
```{r}
a3<- Arima(price, order=c(0,1,1), seasonal=c(0,1,1))
fit3<- fitted(a3)

plot(price)
lines(fit3, col=2)

f3<- forecast(a3)
plot(f3)

r3<- residuals(a3)
tsdisplay(r3) 
```
Fourth Arima model
```{r}
a4<- Arima(price, order=c(0,1,2), seasonal=c(0,1,1))
fit4<- fitted(a4)

plot(price)
lines(fit4, col=2)

f4<- forecast(a4)
autoplot(f4)

r4<- residuals(a4)
tsdisplay(r4) 
```

Fifth Arima model
```{r}
auto.a<- auto.arima(price)
auto.a

autoplot(forecast(auto.a))
checkresiduals(auto.a)
```

```{r}
##plot of seasonal differentiated data, with ACF and PACF
tsdisplay(diff(price,12), main="seasonal differenced data", xlab="year")

##We fit an ARIMA model base on the inspection of ACF and PACF with 3 AR components
fit<- Arima(price, order=c(3,0,1),seasonal=c(0,1,2), lambda=0)
summary(fit)

##Check residuals
tsdisplay(residuals(fit))
Box.test(residuals(fit), lag=36,fitdf=6, type="Ljung")


##perform the forecasting
f<- forecast(fit)

plot(f, ylab="sales", xlab="year")
```

```{r}
air.model <- Arima(window(price,end=146),order=c(0,1,1),
                   seasonal=list(order=c(0,1,1),period=12),lambda=0)
plot(forecast(air.model,h=24))
lines(price)

# Apply fitted model to later data
air.model2 <- Arima(window(price,start=1),model=air.model)

# in-sample one-step forecasts
accuracy(air.model)
# out-of-sample one-step forecasts
accuracy(air.model2)
```

### ARMAX Models

```{r}
armax1<- Arima(price, xreg=dataset_log$dollar_circulation, order=c(1,0,1))
res1<- residuals(armax1)
Acf(res1)

fitted(armax1)
plot(price)
lines(fitted(armax1), col=2)
```

