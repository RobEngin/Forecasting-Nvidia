---
title: "R Notebook"
output: html_notebook
---

```{r}
library(ggplot2)
library(dplyr)
library(corrplot)
library(readxl)
library(lmtest) 
library(forecast)
library(DIMORA)
library(fpp2)
library(tidyr)
library(lubridate)
```

```{r}
number_of_employees <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/number-of-employees.xlsx")
quarterly_net_income <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/quarterly-net-income.xlsx")
research_development_spending <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/research-development-spending.xlsx")
revenue_by_quarter <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/revenue-by-quarter.xlsx")
revenue_by_segment <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/revenue-by-segment.xlsx")
```

```{r}
# Rimuovere le prime 4 righe e l'ultima riga
revenue_by_quarter <- revenue_by_quarter %>%
  slice(5:(n() - 1))

research_development_spending <- research_development_spending %>%
  slice(4:n())

number_of_employees <- number_of_employees %>%
  slice(2:n())
```


```{r}
tt <- 1:NROW(revenue_by_quarter)
revenue <- revenue_by_quarter$billion
net_income <- quarterly_net_income$income

ggplot(data = revenue_by_quarter, aes(x = tt, y = billion)) +
  geom_line() +
  labs(x = "Quarter", y = "Billion", title = "Quarter vs. Billion")
```

```{r}
# Normalizzare i dati
normalize <- function(x) {
  return((x - mean(x)) / sd(x))
}

# Ripetere i valori annuali per ciascuno dei quattro trimestri
repeat_annual_data <- function(annual_data) {
  return(rep(annual_data, each = 4))
}

employees_repeated <- repeat_annual_data(number_of_employees$employees)
spending_repeated <- repeat_annual_data(research_development_spending$billion)

# Normalizzare i dati annuali ripetuti
n_employees <- normalize(employees_repeated)
n_spending <- normalize(spending_repeated)

n_revenue <- normalize(revenue)
n_net_income <- normalize(net_income)

# Creare un dataframe combinato
combined_data <- data.frame(
  Quarter = tt,
  Revenue = n_revenue,
  Net_Income = n_net_income,
  Employees = n_employees,
  Spending = n_spending
)

# Trasformare il dataframe in formato lungo
combined_data_long <- combined_data %>%
  pivot_longer(cols = c("Revenue", "Net_Income", "Employees", "Spending"), names_to = "Metric", values_to = "Value")

# Creare il grafico
ggplot(data = combined_data_long, aes(x = Quarter, y = Value, color = Metric)) +
  geom_line() +
  labs(x = "Quarter", y = "Value", title = "Quarterly Revenue and Net Income") +
  theme_minimal()

```

```{r}
# Sostituisci i valori NA con zero
revenue_by_segment[is.na(revenue_by_segment)] <- 0

# Trasforma i dati in formato lungo per ggplot2
df_long <- revenue_by_segment %>%
  pivot_longer(cols = -year, names_to = "category", values_to = "value")

# Seleziona una palette di colori con abbastanza variazioni
palette_colors <- c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", 
                    "#ffd92f", "#e5c494", "#b3b3b3", "#1b9e77", "#d95f02", 
                    "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666")

# Crea il grafico
ggplot(df_long, aes(x = factor(year), y = value, fill = category)) +
  geom_bar(stat = "identity", position = "stack") +  # Usa "stack" per impilare le barre
  labs(x = "Year", y = "Value", title = "Annual Data by Category") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "right",  # Sposta la legenda a destra
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 8)) +
  scale_fill_manual(values = palette_colors) +
  guides(fill = guide_legend(ncol = 1, byrow = TRUE))  # Migliora la leggibilità della legenda

```

```{r}
# Creare la serie temporale
revenue_ts <- ts(revenue_by_quarter$billion, start=c(2007, 1), frequency=4)

# Decomporre la serie temporale
decomposed_revenue <- stl(revenue_ts, s.window="periodic")

# Visualizzare la decomposizione
autoplot(decomposed_revenue) +
  labs(title = "Decomposition of Quarterly Revenue", x = "Time")

# Estrarre la componente stagionale
seasonal_component <- decomposed_revenue$time.series[, "seasonal"]

# Creare il grafico della stagionalità
ggplot(data = data.frame(Quarter = time(revenue_ts), Seasonal = seasonal_component), 
       aes(x = Quarter, y = Seasonal)) +
  geom_line(color = "blue") +
  labs(x = "Quarter", y = "Seasonal Component", title = "Seasonal Component of Quarterly Revenue") +
  theme_minimal()

```


```{r}
##check the residuals
resfit1<- residuals(fit1)
plot(resfit1, xlab="Time", ylab="residuals" )
acf(resfit1)

##fit a linear regression model 
fit1 <- lm(revenue~ tt)
summary(fit1)

##plot of the model
plot(tt, revenue, xlab="Time", ylab="Billion")
abline(fit1, col=3)

##check the residuals? are they autocorrelated? Test of DW
dwtest(fit1)
```


```{r}
##let us do the same with a linear model for time series, so we transform the data into a 'ts' object
revenue.ts <- ts(revenue, frequency = 4)
ts.plot(revenue.ts, type="o")

## we fit a linear model with the tslm function
fitts<- tslm(revenue.ts~trend)

###obviously it gives the same results of the first model
summary(fitts)

dwtest(fitts)
```
```{r}
acf(revenue)
pacf(revenue)
```
```{r}
# Differenziazione per rendere stazionaria la serie
diff_revenue <- diff(revenue.ts, differences=1)

# Verificare la stazionarietà
acf(diff_revenue, main="ACF of Differenced Revenue")
pacf(diff_revenue, main="PACF of Differenced Revenue")

```
```{r}
# Utilizzare auto.arima per trovare il miglior modello ARIMA
best_arima_model <- auto.arima(revenue.ts)
summary(best_arima_model)

# Visualizzare i residui del modello
checkresiduals(best_arima_model)

```

```{r}
# Installare e caricare i pacchetti necessari
if (!require(forecast)) {
    install.packages("forecast")
}
if (!require(tseries)) {
    install.packages("tseries")
}

library(forecast)
library(tseries)

# Creare la serie temporale
revenue_ts <- ts(revenue_by_quarter$billion, start=c(2007, 1), frequency=4)

# Differenziare i dati per renderli stazionari
diff_revenue <- diff(revenue_ts, differences=1)

# Calcolare e tracciare l'ACF e la PACF della serie differenziata
acf(diff_revenue, main="ACF of Differenced Revenue")
pacf(diff_revenue, main="PACF of Differenced Revenue")

# Utilizzare auto.arima per trovare il miglior modello ARIMA
best_arima_model <- auto.arima(revenue_ts)
summary(best_arima_model)

residuals_arima <- residuals(best_arima_model)

# Visualizzare i residui del modello
checkresiduals(best_arima_model)

# Prevedere i prossimi 8 trimestri
forecast_horizon <- 12
forecast_revenue <- forecast(best_arima_model, h = forecast_horizon)

# Visualizzare le previsioni
autoplot(forecast_revenue) +
  labs(title = "Revenue Forecast with ARIMA", x = "Date", y = "Revenue (Billion)") +
  autolayer(fitted(best_arima_model), series = "Fitted", PI = FALSE)

```
```{r}
air.model <- Arima(window(revenue_ts,end=2023),order=c(2,0,2),
                   seasonal=list(order=c(0,1,0),period=4),lambda=0)
plot(forecast(air.model,h=12))
lines(revenue_ts)
```



```{r}
#data transformed as time series
revenue.ts<-ts(revenue, frequency=4)

#Model with trend and seasonality
fit3 <- tslm(revenue.ts~ trend+season)
summary(fit3)

#check the residuals
residuals_arima <- residuals(fit3)

plot(residuals_arima, ylab="residuals")
dwtest(fit3)

###plot of the model
plot(revenue.ts, ylab="Billion", xlab="Time")
lines(fitted(fit3), col=2)
```

```{r}
# Plot dei residui
plot(residuals_arima, main="Residuals of ARIMA Model", ylab="Residuals", xlab="Time")
abline(h = 0, col = "red")

# Autocorrelazione dei residui
acf(residuals_arima, main="ACF of Residuals")

# Test di normalità (ad esempio, test di Shapiro-Wilk)
shapiro.test(residuals_arima)

# Plot della varianza dei residui
plot(residuals_arima^2, main="Squared Residuals of ARIMA Model", ylab="Squared Residuals", xlab="Time")

# Verificare i residui del modello con checkresiduals
checkresiduals(best_arima_model)

```




