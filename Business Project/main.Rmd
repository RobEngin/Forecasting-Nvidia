---
title: "R Notebook"
output: html_notebook
---

```{r}
library(ggplot2)
library(dplyr)
library(corrplot)
library(readxl)
library(lmtest) 
library(forecast)
library(DIMORA)
library(fpp2)
library(tidyr)
library(lubridate)
```

```{r}
number_of_employees <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/number-of-employees.xlsx")
quarterly_net_income <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/quarterly-net-income.xlsx")
research_development_spending <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/research-development-spending.xlsx")
revenue_by_quarter <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/revenue-by-quarter.xlsx")
revenue_by_segment <- read_excel("~/Desktop/Unipd/GitHub/Business-Project/Business Project/revenue-by-segment.xlsx")
```

```{r}
# Rimuovere le prime 4 righe e l'ultima riga
revenue_by_quarter <- revenue_by_quarter %>%
  slice(5:(n() - 1))

research_development_spending <- research_development_spending %>%
  slice(4:n())

number_of_employees <- number_of_employees %>%
  slice(2:n())
```


```{r}
# Normalizzare i dati
normalize <- function(x) {
  return((x - mean(x)) / sd(x))
}

# Ripetere i valori annuali per ciascuno dei quattro trimestri
repeat_annual_data <- function(annual_data) {
  return(rep(annual_data, each = 4))
}

employees_repeated <- repeat_annual_data(number_of_employees$employees)
spending_repeated <- repeat_annual_data(research_development_spending$billion)

# Normalizzare i dati annuali ripetuti
n_employees <- normalize(employees_repeated)
n_spending <- normalize(spending_repeated)

n_revenue <- normalize(revenue_by_quarter$billion)
n_net_income <- normalize(quarterly_net_income$income)

tt <- 1:NROW(revenue_by_quarter)

# Creare un dataframe combinato
combined_data <- data.frame(
  Quarter = tt,
  Revenue = n_revenue,
  Net_Income = n_net_income,
  Employees = n_employees,
  Spending = n_spending
)

# Trasformare il dataframe in formato lungo
combined_data_long <- combined_data %>%
  pivot_longer(cols = c("Revenue", "Net_Income", "Employees", "Spending"), names_to = "Metric", values_to = "Value")

# Creare il grafico
ggplot(data = combined_data_long, aes(x = Quarter, y = Value, color = Metric)) +
  geom_line() +
  labs(x = "Quarter", y = "Value", title = "Quarterly Revenue and Net Income") +
  theme_minimal()

```
```{r}

ts_employees <- ts(employees_repeated, frequency = 4)
ts_net_income <- ts(quarterly_net_income$income, frequency = 4)
ts_spending <- ts(spending_repeated, frequency = 4)
ts_revenue <- ts(revenue_by_quarter$billion, frequency = 4)

tslm_rev <- tslm(ts_revenue ~ trend+season+ts_spending+ts_net_income+ts_employees)
summary(tslm_rev) # ts_employees non è significativa

library(car)
vif(tslm_rev)

```


```{r}
# Sostituisci i valori NA con zero
revenue_by_segment[is.na(revenue_by_segment)] <- 0

# Trasforma i dati in formato lungo per ggplot2
df_long <- revenue_by_segment %>%
  pivot_longer(cols = -year, names_to = "category", values_to = "value")

# Seleziona una palette di colori con abbastanza variazioni
palette_colors <- c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", 
                    "#ffd92f", "#e5c494", "#b3b3b3", "#1b9e77", "#d95f02", 
                    "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666")

# Crea il grafico
ggplot(df_long, aes(x = factor(year), y = value, fill = category)) +
  geom_bar(stat = "identity", position = "stack") +  # Usa "stack" per impilare le barre
  labs(x = "Year", y = "Value", title = "Annual Data by Category") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "right",  # Sposta la legenda a destra
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 8)) +
  scale_fill_manual(values = palette_colors) +
  guides(fill = guide_legend(ncol = 1, byrow = TRUE))  # Migliora la leggibilità della legenda

```

```{r}
# Assicurati che tutte le colonne utilizzate per la correlazione siano numeriche
# Supponiamo che i dati siano nelle colonne 2 delle rispettive tabelle (adatta l'indice di colonna se necessario)
data_combined <- data.frame(
  revenue = revenue_by_quarter$billion,
  net_income = quarterly_net_income$income,
  employees = employees_repeated,
  rnd_spending = spending_repeated
)

# Calcolo della matrice di correlazione
correlation_matrix <- cor(data_combined, use = "complete.obs")

# Visualizzazione della matrice di correlazione
print(correlation_matrix)

# Se desideri una visualizzazione grafica
library(corrplot)
corrplot(correlation_matrix, method = "circle")

# Creazione delle serie temporali
revenue.ts <- ts(revenue_by_quarter$billion, frequency = 4)
net_income.ts <- ts(quarterly_net_income$income, frequency = 4)
employees_repeated <- ts(employees_repeated, frequency = 4)
spending_repeated <- ts(spending_repeated, frequency = 4)

# Differenziazione delle serie temporali
diff_revenue <- diff(revenue.ts)
diff_net_income <- diff(net_income.ts)
diff_employees <- diff(employees_repeated)
diff_spending <- diff(spending_repeated)

# Creazione del dataframe con le serie differenziate
data_combined_diff <- data.frame(
  diff_revenue = as.numeric(diff_revenue),
  diff_net_income = as.numeric(diff_net_income),
  diff_employees = as.numeric(diff_employees),
  diff_spending = as.numeric(diff_spending)
)

# Calcolo della matrice di correlazione
correlation_matrix_diff <- cor(data_combined_diff, use = "complete.obs")

# Visualizzazione della matrice di correlazione
print(correlation_matrix_diff)

# Visualizzazione grafica della matrice di correlazione
corrplot(correlation_matrix_diff, method = "circle")

```


```{r}
tt <- 1:NROW(revenue_by_quarter)
revenue <- revenue_by_quarter$billion
net_income <- quarterly_net_income$income
revenue_by_quarter$quarter <- as.yearqtr(revenue_by_quarter$quarter, format = "Q%q '%y")

tsdisplay(revenue)

# Calcolo della media mobile (esempio con finestra di 12 mesi per dati mensili)
moving_average <- ma(revenue, order = 12)

ggplot(data = revenue_by_quarter, aes(x = tt)) +
  geom_line(aes(y = billion)) +
  geom_line(aes(y = moving_average), color = "red") +
  labs(x = "Quarter", y = "Billion", title = "Quarter vs. Billion")



```
```{r}
# Aggiungi colonne per anno e trimestre
revenue_by_quarter <- revenue_by_quarter %>%
  mutate(
    year = as.integer(format(quarter, "%Y")),
    quarter_num = as.integer(format(quarter, "%q"))
  )

# Crea un grafico stagionale
ggplot(revenue_by_quarter, aes(x = quarter_num, y = billion, group = year, color = factor(year))) +
  geom_line() +
  scale_x_continuous(breaks = 1:4, labels = c("Q1", "Q2", "Q3", "Q4")) +
  labs(x = "Quarter", y = "Revenue (Billion)", title = "Seasonal Plot: Revenue by Quarter", color = "Year") +
  theme_minimal() +
  theme(legend.position = "right")
```



```{r}
#Dato che i dati mostrano una tendenza, potrebbe essere necessario differenziare i dati per renderli stazionari prima di applicare un modello ARIMA.

#La differenziazione è una tecnica utilizzata nell'analisi delle serie temporali per trasformare una serie non stazionaria in una stazionaria. Una serie temporale è stazionaria quando le sue proprietà statistiche, come la media e la varianza, non cambiano nel tempo. La stazionarietà è un requisito fondamentale per l'applicazione di molti modelli di serie temporali, come l'ARIMA, in quanto permette di assumere che i processi generati dai dati siano invarianti nel tempo.

# Differenziazione dei dati
diff_revenue <- diff(revenue)

# Visualizzazione dei dati differenziati
plot(diff_revenue, type = "l", main = "Differenced Revenue")

# Test di stazionarietà (ad esempio, test di Dickey-Fuller aumentato)
library(tseries)
adf.test(diff_revenue)


```



```{r}
# Creare la serie temporale
revenue_ts <- ts(revenue_by_quarter$billion, start=c(2007, 1), frequency=4)

# Decomporre la serie temporale
decomposed_revenue <- stl(revenue_ts, s.window="periodic")

# Visualizzare la decomposizione
autoplot(decomposed_revenue) +
  labs(title = "Decomposition of Quarterly Revenue", x = "Time")

# Estrarre la componente stagionale
seasonal_component <- decomposed_revenue$time.series[, "seasonal"]

# Creare il grafico della stagionalità
ggplot(data = data.frame(Quarter = time(revenue_ts), Seasonal = seasonal_component), 
       aes(x = Quarter, y = Seasonal)) +
  geom_line(color = "blue") +
  labs(x = "Quarter", y = "Seasonal Component", title = "Seasonal Component of Quarterly Revenue") +
  theme_minimal()

```


```{r}
library(forecast)
library(tseries)

# Creare la serie temporale
revenue_ts <- ts(revenue_by_quarter$billion, start=c(2007, 1), frequency=4)

# Differenziare i dati per renderli stazionari
diff_revenue <- diff(revenue_ts, differences=1)

# Calcolare e tracciare l'ACF e la PACF della serie differenziata
acf(diff_revenue, main="ACF of Differenced Revenue")
pacf(diff_revenue, main="PACF of Differenced Revenue")

# Utilizzare auto.arima per trovare il miglior modello ARIMA
best_arima_model <- auto.arima(revenue_ts)
summary(best_arima_model)

residuals_arima <- residuals(best_arima_model)

# Visualizzare i residui del modello
checkresiduals(best_arima_model)

# Prevedere i prossimi 8 trimestri
forecast_horizon <- 12
forecast_revenue <- forecast(best_arima_model, h = forecast_horizon)

# Visualizzare le previsioni
autoplot(forecast_revenue) +
  labs(title = "Revenue Forecast with ARIMA", x = "Date", y = "Revenue (Billion)") +
  autolayer(fitted(best_arima_model), series = "Fitted", PI = FALSE)

```
```{r}
air.model <- Arima(window(revenue_ts,end=2022),order=c(2,0,2),
                   seasonal=list(order=c(0,1,0),period=4),lambda=0)
plot(forecast(air.model,h=12))
lines(revenue_ts)
```



```{r}
# Funzione per visualizzare il modello
plot_model <- function(model, data) {
  plot(data, ylab="Billion", xlab="Time")
  lines(fitted(model), col=2)
}

plot_model_forecast <- function(model, data, forecast_horizon) {
  forecasted_values <- forecast(model, h = forecast_horizon)
  plot(forecasted_values, ylab = "Billion", xlab = "Time")
  lines(fitted(model), col = 2)
}

# Modello con trend e stagionalità
fit_lm <- tslm(revenue.ts ~ trend + season)
summary(fit_lm)

# Verifica dei residui
checkresiduals(fit_lm)

# Visualizzazione del modello
plot_model(fit_lm, revenue.ts)

plot_model_forecast(fit_lm, revenue.ts, forecast_horizon = 8)

```


```{r}
# Modello Holt-Winters
fit_hw <- hw(revenue.ts, seasonal = "additive")
summary(fit_hw)

# Verifica dei residui
checkresiduals(fit_hw)

# Visualizzazione del modello
plot_model(fit_hw, revenue.ts)

plot_model_forecast(fit_hw, revenue.ts, forecast_horizon = 8)

```
```{r}
# Modello di regressione lineare con componente quadratica
fit_lm_quad <- tslm(revenue.ts ~ trend + I(trend^2) + season)
summary(fit_lm_quad)

# Verifica dei residui
checkresiduals(fit_lm_quad)

# Visualizzazione del modello
plot_model(fit_lm_quad, revenue.ts)

plot_model_forecast(fit_lm_quad, revenue.ts, forecast_horizon = 8)

```
```{r}
# Modello GAM con specifica dei nodi
fit_gam <- gam(revenue ~ s(time, k = 10) + s(quarter, bs = "cc", k = 4), data = revenue_gam_df)
summary(fit_gam)

# Verifica dei residui
residuals_gam <- residuals(fit_gam)
plot(residuals_gam, ylab = "residuals")
dwtest(residuals_gam ~ revenue_gam_df$time)

# Visualizzazione del modello
plot(revenue.ts, ylab = "Billion", xlab = "Time")
lines(fitted(fit_gam), col = 2)


```

